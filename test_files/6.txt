.ORIG x3000

JSR Mod
HALT


; R2 = R0 % R1
; R0 >= 0
; R1 >  0
Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R3, ModR3
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1
    
    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE
    
    ; We now are sure R0 > R1
    LEA R3, ModStorage
    
    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1
    
    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0
    
    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip
        
        ; Check if R0 < R1
        ADD R4, R2, R0
        BRnz ModDone
        
        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0
        
        Brnzp ModLoop2
    
    ModDone
    LD R4, ModR4
    LD R3, ModR3
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR3 .BLKW #1
ModR4 .BLKW #1

.END
