.ORIG x3000

; Read matrix A
LEA R0, MATRIX_A
JSR ReadMatrix

; Read matrix B
LEA R0, MATRIX_B
JSR ReadMatrix

; Multiply matrices A and B, result goes to C
LEA R0, MATRIX_A
LEA R1, MATRIX_B
LEA R2, MATRIX_C

JSR MultMatrix

LEA R2, MATRIX_C
JSR PrintMatrix

; Print output matrix C


HALT

; Storage for 3 3x3 matrices
MATRIX_A .BLKW #9
MATRIX_B .BLKW #9
MATRIX_C .BLKW #9


; Reads a 3x3 matrix from the console
; The matrix is stored in pointer R0
ReadMatrix
    ST R0, ReadMatrixR0
    ST R1, ReadMatrixR1
    ST R2, ReadMatrixR2
    ST R7, ReadMatrixR7

    ; Loop 9 times
    LD R2, NINE

    ReadMatrixLoop
        JSR ReadNum
        STR R1, R0, #0
        ADD R0, R0, #1
        ADD R2, R2, #-1
        BRp ReadMatrixLoop
    
    LD R7, ReadMatrixR7
    LD R2, ReadMatrixR2
    LD R1, ReadMatrixR1
    LD R0, ReadMatrixR0
RET

; Storage for ReadMatrix
ReadMatrixR0 .BLKW #1
ReadMatrixR1 .BLKW #1
ReadMatrixR2 .BLKW #1
ReadMatrixR7 .BLKW #1


; Reads a positive integer from the console
; The integer is written to R1
ReadNum
    ; Store needed registers
    ST R0, ReadNumR0
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    LD R3, ToDigit
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC
        
        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone
        
        ADD R2, R0, #-9
        BRp ReadNumDone
        
        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R0, ReadNumR0
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR0 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


; Multiplies 3x3 matrices A and B into C
; Pointers to A, B and C are stored in R0, R1 and R2 respectively
MultMatrix
    ; Store our matrix pointers
    ST R0, MultMatrixA
    ST R1, MultMatrixB
    ST R2, MultMatrixC
    ; Store other registers
    ST R3, MultMatrixR3
    ST R4, MultMatrixR4
    ST R5, MultMatrixR5
    ST R6, MultMatrixR6
    ST R7, MultMatrixR7
    
    ; A index
    LD R3, EIGHT
    ; C index
    LD R5, EIGHT
    
    MultMatrixL1
        ; Reset B index
        LD R4, EIGHT
        MultMatrixL2
            ; Initialize intermediate result
            AND R6, R6, #0
            
            MultMatrixL3
                ; Get B
                LD R1, MultMatrixB
                ADD R1, R1, R4
                LDR R1, R1, #0
                
                ; Get A
                LD R2, MultMatrixA
                ADD R2, R2, R3
                LDR R2, R2, #0
                
                ; Multiply and store intermediate
                JSR Mult
                ADD R6, R6, R0
                
                ; Modify A index
                ADD R3, R3, #-1
                ; Modify B index
                ADD R4, R4, #-3
                BRzp MultMatrixL3

            ; Put value in C
            LD R2, MultMatrixC
            ADD R2, R2, R5
            STR R6, R2, #0
            
            ADD R5, R5, #-1
            
            ; Undo modifications B index
            ADD R4, R4, #8

            ; Undo modifications A index
            ADD R3, R3, #3

            ; Loop if needed
            ADD R7, R4, #-6
            BRzp MultMatrixL2

        ; Change A index
        ADD R3, R3 #-3
        BRp MultMatrixL1

    ; Load all stored values back
    LD R0, MultMatrixA
    LD R1, MultMatrixB
    LD R2, MultMatrixC
    LD R3, MultMatrixR3
    LD R4, MultMatrixR4
    LD R5, MultMatrixR5
    LD R6, MultMatrixR6
    LD R7, MultMatrixR7
RET

; Storage for MultMatrix
MultMatrixA  .BLKW #1
MultMatrixB  .BLKW #1
MultMatrixC  .BLKW #1
MultMatrixR3 .BLKW #1
MultMatrixR4 .BLKW #1
MultMatrixR5 .BLKW #1
MultMatrixR6 .BLKW #1
MultMatrixR7 .BLKW #1


; Multiplies R1 by R2
; Result is stored in R0
Mult
    ST R1, MultR1
    ST R2, MultR2
    ST R3, MultR3
    ST R4, MultR4

    AND R0, R0, #0

    ; Check if R1 == 0 || R2 == 0
    ADD R1, R1, #0
    BRz MultDone
    
    ADD R2, R2, #0
    BRz MultDone
    
    ; R3 is used to check if a certain bit is 1
    ADD R3, R0, #1
    
    MultLoop
        AND R4, R1, R3

        BRz MultSkip
            ; If current bit is 1
            ADD R0, R0, R2
            NOT R4, R3
            AND R1, R1, R4
            BRz MultDone
    
        MultSkip
        ADD R2, R2, R2
        ADD R3, R3, R3
        BRnzp MultLoop

    MultDone
    LD R4, MultR4
    LD R3, MultR3
    LD R2, MultR2
    LD R1, MultR1
RET

; Storage for Mult
MultR1 .BLKW #1
MultR2 .BLKW #1
MultR3 .BLKW #1
MultR4 .BLKW #1


; Prints the 3x3 matrix to which R2 is pointing to console
PrintMatrix
    ST R0, PrintMatrixR0
    ST R1, PrintMatrixR1
    ST R2, PrintMatrixR2
    ST R3, PrintMatrixR3
    ST R7, PrintMatrixR7

    LD R3, THREE
    
    PrintMatrixLoop
        ; First number of row
        LDR R1, R2, #0
        JSR PrintNum
        LD R0, ASCII_SPACE
        PUTC
        
        ADD R2, R2, #1
        ; Second number of row
        LDR R1, R2, #0
        JSR PrintNum
        LD R0, ASCII_SPACE
        PUTC
        
        ADD R2, R2, #1
        ; Last number of row
        LDR R1, R2, #0
        JSR PrintNum
        LD R0, ASCII_NEWLINE
        PUTC
        
        ADD R2, R2, #1
        ADD R3, R3, #-1
        BRp PrintMatrixLoop

    LD R7, PrintMatrixR7
    LD R3, PrintMatrixR3
    LD R2, PrintMatrixR2
    LD R1, PrintMatrixR1
    LD R0, PrintMatrixR0
    RET

; Storage for PrintMatrix
PrintMatrixR0 .BLKW #1
PrintMatrixR1 .BLKW #1
PrintMatrixR2 .BLKW #1
PrintMatrixR3 .BLKW #1
PrintMatrixR7 .BLKW #1


; Prints the number in R1 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4

    ; Check for negative numbers
    AND R1, R1, R1
    BRp PrintNumPos
    BRz PrintNumDone
        NOT R1, R1
        ADD R1, R1, #1
        LD R0, ASCII_MINUS
        PUTC
    
    PrintNumPos
    
    ; R2 stores whether the first digit has been found
    AND R2, R2, #0

    ; R3 stores a pointer to the current factor
    LEA R3, PrintNumF5
    ; R4 stores the factor
    LDR R4, R3, #0

    PrintNumLoop
        ; R0 stores the ascii code of the current digit
        LD R0, ASCII_SLASH

        PrintNumMod
            ADD R0, R0, #1
            ADD R1, R1, R4
            BRzp PrintNumMod

        ; Add the last iter back
        NOT R4, R4
        ADD R4, R4, #1
        ADD R1, R1, R4
        
        ; Check if should print
        AND R2, R2, R2
        BRp PrintNumPUTC
        
        ; Check if zero
        LD R4, ASCII_NZERO
        ADD R4, R0, R4
        BRz PrintNumNULL
        
        ; First digit!
        ADD R2, R2, #1
        
        PrintNumPUTC PUTC

        PrintNumNULL
        
        ADD R3, R3, #1
        LDR R4, R3, #0
        BRn PrintNumLoop
    
    PrintNumDone
    ; Last digit always needs to be printed
    LD R0, ASCII_SLASH
    ADD R0, R0, #1
    ADD R0, R0, R1
    
    PUTC

    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
    RET

; For printing
ASCII_MINUS   .FILL x2D
ASCII_SLASH   .FILL x2F
ASCII_NZERO   .FILL x-30
ASCII_NEWLINE .FILL x0A
ASCII_SPACE   .FILL x20

; All factors of 10 we need
PrintNumF5 .FILL #-10000
PrintNumF4 .FILL #-1000
PrintNumF3 .FILL #-100
PrintNumF2 .FILL #-10
PrintNumF0 .FILL #0

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1


; "Global" variables
NINE  .FILL #9
EIGHT .FILL #8
THREE .FILL #3

.END
