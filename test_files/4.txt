.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END
.ORIG x3000

JSR Main


; Checks if R0 is prime
isPrime
    ST R0, isPrimeR0
    ST R1, isPrimeR1
    ST R2, isPrimeR2
    ST R3, isPrimeR3
    ST R4, isPrimeR4
    ST R5, isPrimeR5
    ST R7, isPrimeR7

    ; R1 stores potential divisor
    AND R1, R1, #0

    ; Check for 2
    ADD R2, R0, #-2
    BRz isPrimeTrue

    ; Check for even
    AND R2, R0, x0001

    BRnp isPrimeOdd
        ADD R1, R1, #2
        BRnzp isPrimeFalse

    isPrimeOdd

    ; R1 stores counter
    ; R4 stores square of counter
    ; R5 stores negative R0
    ADD R1, R1, #3
    ADD R4, R1, #6
    NOT R5, R0
    ADD R5, R5, #1

    isPrimeLoop
        ; Go until square > R0
        ADD R2, R4, R5
        BRp isPrimeTrue

        JSR Mod

        ; If module is 0
        AND R3, R3, R3
        BRz isPrimeFalse

        ; Increment
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R4, R4, R2

        ADD R1, R1, #2
        ADD R4, R4, #4

        BRnzp isPrimeLoop

    isPrimeTrue
        JSR PrintNum

        LEA R0, isPrimeTrueStr
        PUTS

        BRnzp isPrimeDone

    isPrimeFalse
        JSR PrintNum

        LEA R0, isPrimeFalseStr
        PUTS

        AND R0, R1, R1
        JSR PrintNum

        LD R0, Newline
        PUTC

    isPrimeDone

    LD R7, isPrimeR7
    LD R5, isPrimeR5
    LD R4, isPrimeR4
    LD R3, isPrimeR3
    LD R2, isPrimeR2
    LD R1, isPrimeR1
    LD R0, isPrimeR0
RET

isPrimeTrueStr  .STRINGZ " is a prime number\n"
isPrimeFalseStr .STRINGZ " is not a prime number as it is divisible by "
Newline .FILL x0A

; Storage for isPrime
isPrimeR0 .BLKW #1
isPrimeR1 .BLKW #1
isPrimeR2 .BLKW #1
isPrimeR3 .BLKW #1
isPrimeR4 .BLKW #1
isPrimeR5 .BLKW #1
isPrimeR7 .BLKW #1



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Prints the number in R0 to the console
PrintNum
    ST R0, PrintNumR0
    ST R1, PrintNumR1
    ST R2, PrintNumR2
    ST R3, PrintNumR3
    ST R4, PrintNumR4
    ST R5, PrintNumR5
    ST R7, PrintNumR7

    ; R4 contains start of string
    LEA R4, PrintNumStr
    ADD R4, R4, #4

    LD R1, PrintNum10
    LD R5, ToASCII

    PrintNumLoop
        ; Divide R0 by 10, modulo is digit
        JSR Divmod
        ; Save digit
        ADD R3, R3, R5
        STR R3, R4, #0

        AND R0, R2, R2
        BRz PrintNumDone

        ADD R4, R4, #-1
        BRnzp PrintNumLoop

    PrintNumDone

    AND R0, R4, R4
    PUTS

    LD R7, PrintNumR7
    LD R5, PrintNumR5
    LD R4, PrintNumR4
    LD R3, PrintNumR3
    LD R2, PrintNumR2
    LD R1, PrintNumR1
    LD R0, PrintNumR0
RET

ToASCII    .FILL #48
PrintNum10 .FILL #10

; Storage for PrintNum
PrintNumR0 .BLKW #1
PrintNumR1 .BLKW #1
PrintNumR2 .BLKW #1
PrintNumR3 .BLKW #1
PrintNumR4 .BLKW #1
PrintNumR5 .BLKW #1
PrintNumR7 .BLKW #1

PrintNumStr .BLKW #6


Mod
    ST R0, ModR0
    ST R1, ModR1
    ST R2, ModR2
    ST R4, ModR4

    ; R1 == 1 ?
    ADD R2, R1 #-1

    BRp ModNot1
        AND R2, R0, R0
        BRnzp ModDone
    ModNot1

    ; R1 = -R1
    NOT R1, R1
    ADD R1, R1, #1

    ; R1 >= R0 ?
    ADD R2, R0, R1

    BRp ModNotGE
        ; R1 >= R0
        AND R2, R2, #0
        BRnzp ModDone
    ModNotGE

    ; We now are sure R0 > R1
    LEA R3, ModStorage

    ; Store R0 in R2 for result
    AND R2, R0, R0
    ; Save base R1 in R0
    AND R0, R1, R1

    ; Get maximum n for which  R0 - (R1 * 2^n) >= 0
    ModLoop1
        ; Save R1 for later
        STR R1, R3, #0
        ; Increment address
        ADD R3, R3, #1
        ; Double R1
        ADD R1, R1, R1
        ; Check if R1 >= R0
        ADD R4, R2, R1
        BRp ModLoop1

    ; Go back 1
    ADD R3, R3, #-1
    LDR R1, R3, #0

    ; Keep removing with max n until R0 < R1
    ModLoop2
        ; Store R2 and calculate
        AND R4, R2, R2
        ADD R2, R2, R1

        BRzp ModSkip
            ; Undo if R2 < 0
            AND R2, R4, R4
        ModSkip

        ; Check if R0 < R1
        ADD R4, R2, R0
        BRn ModDone

        ; Load earlier R1
        ADD R3, R3, #-1
        LDR R1, R3, #0

        Brnzp ModLoop2

    ModDone
    AND R3, R2, R2

    LD R4, ModR4
    LD R2, ModR2
    LD R1, ModR1
    LD R0, ModR0
    RET

; Storage for Mod
ModStorage .BLKW #14
ModR0 .BLKW #1
ModR1 .BLKW #1
ModR2 .BLKW #1
ModR4 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Performs division and modulo operations on R0 and R1
; R2 = R0 / R1
; R3 = R0 % R1
Divmod
    ST R4, DivmodR4
    ST R5, DivmodR5

    AND R3, R0, R0
    AND R2, R2, #0

    ; Inverse of R1
    NOT R4, R1
    ADD R4, R4, #1

    ADD R5, R1, #-1
    BRnp DivmodNot1
        ; R1 == 1
        ADD R2, R2, R0
        AND R3, R3, #0
        ADD R3, R3, R4

        BRnzp DivmodDone
    DivmodNot1

    DivmodLoop
        ADD R3, R3, R4
        BRn DivmodDone

        ADD R2, R2, #1
        BRnzp DivmodLoop

    DivmodDone
    ADD R3, R3, R1

    LD R5, DivmodR5
    LD R4, DivmodR4
RET

; Storage for Divmod
DivmodR4 .BLKW #1
DivmodR5 .BLKW #1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; From exercise 1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Reads a positive integer from the console
; The integer is written to R0
ReadNum
    ; Store needed registers
    ST R1, ReadNumR1
    ST R2, ReadNumR2
    ST R3, ReadNumR3

    ; For conversion
    LD R3, ToDigit

    ; For result
    AND R1, R1, #0

    ; Read until no characters left
    ReadNumLoop
        GETC
        PUTC

        ; Check if valid digit and convert
        ADD R0, R0, R3
        BRn ReadNumDone

        ADD R2, R0, #-9
        BRp ReadNumDone

        ; R0 now contains actual digit
        ; We multiply R1 (intermediate result) by 10
        ADD R1, R1, R1
        ADD R2, R1, R1
        ADD R2, R2, R2
        ADD R1, R1, R2 ; 2xR1 + 8xR1

        ; And add the new digit
        ADD R1, R1, R0

        BRnzp ReadNumLoop

    ReadNumDone

    ; Put result in R0
    AND R0, R1, R1

    ; pop registers
    LD R3, ReadNumR3
    LD R2, ReadNumR2
    LD R1, ReadNumR1
RET

ToDigit .FILL #-48

; Storage for ReadNum
ReadNumR1 .BLKW #1
ReadNumR2 .BLKW #1
ReadNumR3 .BLKW #1


Main
    JSR Readnum

    LEA R2, QueueBase
    AND R1, R0, R0
    AND R3, R0, R0

    ReadLoop
        BRz ReadDone
        JSR ReadNum

        STR R0, R2, #0

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp ReadLoop
    ReadDone

    LEA R2, QueueBase
    AND R1, R3, R3

    PrimeLoop
        BRz PrimeDone

        LDR R0, R2, #0
        JSR isPrime

        ADD R2, R2, #1
        ADD R1, R1, #-1
        BRnzp PrimeLoop
    PrimeDone
HALT

QueueBase .BLKW #256

.END

